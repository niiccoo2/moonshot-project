<!DOCTYPE html>
<html>
<head>
  <title>Space Catch Game</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #000;
      font-family: Arial, sans-serif;
    }
    #game-container {
      position: relative;
      width: 800px;
      height: 600px;
    }
    #video {
      position: absolute;
      top: 0;
      left: 0;
      width: 800px;
      height: 600px;
      object-fit: cover;
      z-index: -1;
    }
    #canvas {
      display: none;
    }
    #score-display {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      z-index: 10;
    }
    #debug-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: white;
      font-size: 14px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      z-index: 10;
    }
  </style>
</head>
<body>

<div id="game-container">
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas" width="320" height="240"></canvas>
  <div id="score-display">Score: 0</div>
  <div id="debug-info">Waiting for hands...</div>
  <div id="game"></div>
</div>

<script>
// Socket.io connection for hand tracking
const socket = io();
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let leftHandPos = { x: 0.5, y: 0.5 };
let rightHandPos = { x: 0.5, y: 0.5 };
let leftGesture = "unknown";
let rightGesture = "unknown";
let bodyKeypoints = null;

// Start camera
navigator.mediaDevices.getUserMedia({ video: true })
  .then(stream => video.srcObject = stream)
  .catch(err => console.error("Camera error:", err));

// Send frames to Flask backend
setInterval(() => {
  ctx.drawImage(video, 0, 0, 320, 240);
  canvas.toBlob(blob => {
    socket.emit("frame", blob);
  }, "image/jpeg", 0.5);
}, 66);

// Receive hand tracking data
socket.on("result", data => {
  // Update hands data from your recognision.py format
  if (data.hands) {
    if (data.hands.left) {
      leftHandPos = { 
        x: data.hands.left.wrist.x, 
        y: data.hands.left.wrist.y 
      };
      leftGesture = data.hands.left.gesture;
    }
    if (data.hands.right) {
      rightHandPos = { 
        x: data.hands.right.wrist.x, 
        y: data.hands.right.wrist.y 
      };
      rightGesture = data.hands.right.gesture;
    }
  }
  
  // Update body keypoints
  if (data.body) {
    bodyKeypoints = data.body;
  }
  
  // Debug display
  const debugText = `
    Left: ${data.hands.left ? data.hands.left.gesture : 'none'} | 
    Right: ${data.hands.right ? data.hands.right.gesture : 'none'}
  `;
  document.getElementById('debug-info').textContent = debugText;
});

// Phaser Game Configuration
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  parent: 'game',
  transparent: true,
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { y: 0 },
      debug: false
    }
  },
  scene: {
    preload: preload,
    create: create,
    update: update
  }
};

const game = new Phaser.Game(config);

let player;
let cursors;
let score = 0;
let fallingObjects;
let lastSpawnTime = 0;
let gameOver = false;

function preload() {
  createSprites(this);
}

function createSprites(scene) {
  // Create Bug Sprite
  const bugGraphics = scene.make.graphics({ x: 0, y: 0, add: false });
  bugGraphics.fillStyle(0x00ff00, 1);
  bugGraphics.fillEllipse(20, 20, 30, 40);
  bugGraphics.fillStyle(0x88ff88, 1);
  bugGraphics.fillEllipse(20, 15, 20, 25);
  bugGraphics.fillStyle(0x000000, 1);
  bugGraphics.fillCircle(15, 12, 3);
  bugGraphics.fillCircle(25, 12, 3);
  bugGraphics.lineStyle(2, 0x006600);
  bugGraphics.strokeCircle(20, 20, 20);
  bugGraphics.generateTexture('bug', 40, 40);
  bugGraphics.destroy();

  // Create Space Cow Sprite
  const cowGraphics = scene.make.graphics({ x: 0, y: 0, add: false });
  cowGraphics.fillStyle(0xffffff, 1);
  cowGraphics.fillEllipse(25, 25, 40, 35);
  cowGraphics.fillEllipse(25, 35, 30, 25);
  cowGraphics.fillStyle(0x000000, 1);
  cowGraphics.fillCircle(35, 25, 8);
  cowGraphics.fillCircle(38, 22, 10);
  cowGraphics.fillCircle(15, 25, 8);
  cowGraphics.fillCircle(12, 22, 10);
  cowGraphics.fillStyle(0xff69b4, 1);
  cowGraphics.fillCircle(20, 30, 3);
  cowGraphics.fillCircle(30, 30, 3);
  cowGraphics.fillStyle(0xffaa00, 1);
  cowGraphics.fillCircle(25, 10, 4);
  cowGraphics.generateTexture('spaceCow', 50, 50);
  cowGraphics.destroy();

  // Create Meteor Sprite
  const meteorGraphics = scene.make.graphics({ x: 0, y: 0, add: false });
  meteorGraphics.fillStyle(0x8b4513, 1);
  meteorGraphics.fillCircle(20, 20, 18);
  meteorGraphics.fillStyle(0x654321, 1);
  meteorGraphics.fillCircle(15, 18, 5);
  meteorGraphics.fillCircle(25, 22, 4);
  meteorGraphics.fillCircle(18, 25, 3);
  meteorGraphics.fillStyle(0xff6600, 0.5);
  meteorGraphics.fillCircle(20, 20, 22);
  meteorGraphics.generateTexture('meteor', 40, 40);
  meteorGraphics.destroy();

  // Create Player Basket
  const basketGraphics = scene.make.graphics({ x: 0, y: 0, add: false });
  basketGraphics.fillStyle(0x8B4513, 1);
  basketGraphics.fillRect(0, 10, 60, 30);
  basketGraphics.fillStyle(0xD2691E, 1);
  basketGraphics.fillRect(5, 15, 50, 20);
  basketGraphics.lineStyle(3, 0x654321);
  for (let i = 10; i < 55; i += 10) {
    basketGraphics.lineBetween(i, 15, i, 35);
  }
  basketGraphics.generateTexture('basket', 60, 40);
  basketGraphics.destroy();
}

function create() {
  player = this.physics.add.sprite(400, 550, 'basket');
  player.setCollideWorldBounds(true);
  
  fallingObjects = this.physics.add.group();
  
  this.physics.add.overlap(player, fallingObjects, collectObject, null, this);
  
  cursors = this.input.keyboard.createCursorKeys();
  
  this.add.text(10, 10, 'Move your hands left/right to control!', {
    fontSize: '18px',
    fill: '#fff',
    stroke: '#000',
    strokeThickness: 4
  });
}

function update(time) {
  if (gameOver) return;
  
  // Average both hands for player position
  const handX = (leftHandPos.x + rightHandPos.x) / 2;
  
  // Check if hands are detected (not at default position)
  const handsDetected = (leftHandPos.x !== 0.5 || rightHandPos.x !== 0.5);
  
  if (handsDetected && handX > 0.05 && handX < 0.95) {
    // Use hand tracking - map normalized coordinates to screen
    player.x = handX * 800;
  } else {
    // Keyboard fallback
    if (cursors.left.isDown) {
      player.x -= 8;
    } else if (cursors.right.isDown) {
      player.x += 8;
    }
  }
  
  // Spawn falling objects
  if (time > lastSpawnTime + 1500) {
    spawnObject(this);
    lastSpawnTime = time;
  }
  
  // Remove objects that fall off screen
  fallingObjects.children.entries.forEach(obj => {
    if (obj.y > 620) {
      obj.destroy();
    }
  });
}

function spawnObject(scene) {
  const x = Phaser.Math.Between(50, 750);
  const types = [
    { key: 'bug', points: 10, speed: 150 },
    { key: 'spaceCow', points: 50, speed: 100 },
    { key: 'meteor', points: -20, speed: 200 }
  ];
  
  const type = Phaser.Utils.Array.GetRandom(types);
  const obj = fallingObjects.create(x, -50, type.key);
  obj.setVelocityY(type.speed);
  obj.points = type.points;
  obj.objectType = type.key;
}

function collectObject(player, object) {
  score += object.points;
  document.getElementById('score-display').textContent = 'Score: ' + score;
  
  const color = object.points > 0 ? 0x00ff00 : 0xff0000;
  const circle = this.add.circle(object.x, object.y, 30, color, 0.5);
  this.tweens.add({
    targets: circle,
    alpha: 0,
    scale: 2,
    duration: 300,
    onComplete: () => circle.destroy()
  });
  
  object.destroy();
}
</script>

</body>
</html>